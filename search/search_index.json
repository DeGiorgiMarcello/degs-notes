{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to my personal notes","text":"<p>Multiple times I've managed to solve a new problem using an old solution, pleased to notice how much time I saved and how the quality of the final result has increased since the first time I had struggled with the original problem.</p> <p>I know, it's simply the definition of the learning curve, but I've always been fascinated by how good the brain is in learning and storing new stuff!</p> <p>In my daily work I often tend to go back and take a look at some old code that I or my colleges have written. Unfortunately this is not always possible, especially if your code is in your company's protected repositories and you are just sitting confortably on the couch, with your personal laptop on the lap, and the work laptop is in your work bag in the other room, or (much more reasonably) if you just changed job. </p> <p>For this reason I've decide to collect here some guides, tutorials and personal notes that could be useful in the future. </p> <p>Enjoy your reading!</p>"},{"location":"about/","title":"About me","text":"<p> My name is Marcello and in the last few years I have been working as Data Engineer developing ETL pipelines and tools to simplify and standardize the whole data cleansing process. I'm a sci-fi books enthusiast, cook and language learner. I strongly believe in knowledge sharing and teaching as a tool for a better learning. </p>"},{"location":"2024/10/18/manage-settings-with-pydantic/","title":"Manage settings with Pydantic","text":"<p> Pydantic is a wonderful library that allows to easily validate your data, simply defining a schema. It is highly customizable and can be used, for instance, to validate data coming from a POST request. </p> <p>In this tutorial we will use it to create a <code>Settings</code> class whose fields can be changed in different ways, triggering any time the validation.</p>","tags":["pydantic","validation","env"]},{"location":"2024/10/18/manage-settings-with-pydantic/#installation","title":"Installation","text":"<p>From v2, pydantic has been split in <code>pydantic</code>, <code>pydantic-core</code> and <code>pydnatic-settings</code>. Let's install the latter one simply with:</p> <p><code>pip install pydantic-settings</code>.</p>","tags":["pydantic","validation","env"]},{"location":"2024/10/18/manage-settings-with-pydantic/#class-definition-and-usage","title":"Class definition and usage","text":"<p>Let's start defining our class. It must extend the pydantic <code>BaseSettings</code> class. No <code>__init__</code> is here needed.</p> <pre><code>from pydantic_settings import BaseSettings\n\nclass Settings(BaseSettings):\n    foo: int = 1\n    bar: str = \"eeee\"\n</code></pre> <p>Extending the class and defining some fields with type hinting is sufficient to let pydantic trigger the validation anytime this values are changed.</p> <p>We can change the values simply defining a new <code>Settings</code> object and passing some values for the fields. This is not so useful for our purpose but can help us to understand how the validation works.</p> <pre><code>Settings(foo=5)\n&gt; Settings(foo=5, bar='eeee')\n</code></pre> <p>but </p> <p><pre><code>Settings(foo=\"five\")\n</code></pre> raise the following exception:</p> <p>ValidationError: 1 validation error for Settings foo   Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='five', input_type=str]</p>","tags":["pydantic","validation","env"]},{"location":"2024/10/18/manage-settings-with-pydantic/#environment-variables","title":"Environment variables","text":"<p>For sure it is more useful to set the settings values directly changing the environment variables. This can be done using the <code>export</code> command on Linux or the <code>set</code> one on Windows. Let's try what happens changing the value of the bar field and to instance a <code>Setting</code> object without any input argument.</p> <p><pre><code>export bar=\"I'm an env variable!\"\n</code></pre> <pre><code>Settings()\n&gt; Settings(foo=1, bar=\"I'm an env variable!\")\n</code></pre></p> <p>If we then pass an input argument it will have the precedence! <pre><code>Settings(bar=\"?\")\n&gt; Settings(foo=1, bar='?')\n</code></pre></p>","tags":["pydantic","validation","env"]},{"location":"2024/10/18/manage-settings-with-pydantic/#using-a-env-file","title":"Using a .env file","text":"<p>Sometimes could be useful to collect more environment variables in a <code>.env</code> file. There is no need to load this file at the beginning of the module, pydantic will do this for us. To do so, the path to the file must be specified. For this and other configuration, our <code>Settings</code> class must be a little bit changed, including the <code>SettingsConfigDict</code>:</p> <pre><code>from pydantic_settings import BaseSettings, SettingsConfigDict\nfrom os.path import expanduser\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(\n        env_file=expanduser(\"~/.env\"), \n        env_file_encoding=\"utf-8\",\n        env_prefix=\"example_\"\n      )\n\n    foo: int = 1\n    bar: str = \"eeee\"\n</code></pre> <p>Let's take a look at the new addings:</p> <ul> <li><code>env_file</code>: the path to the <code>.env</code> file</li> <li><code>env_file_econding</code>: for specifying an encoding different from the one used by your OS</li> <li><code>env_prefix</code>: to specify a prefix that ALL the variables must have to be considered field of the <code>Settings</code> class.</li> </ul> <p>Let's fill our file with the variables:</p> .env<pre><code>example_foo=42\nbar=\"Will I be ignored?\"\n</code></pre> <p>Let's now create another Settings object:</p> <p><pre><code>Settings()\n&gt; Settings(foo=42 bar='eeee')\n</code></pre> As you can see, the <code>bar</code> variable has not been taken, since no <code>env_prefix</code> has been used. Furthermore, the previous values set using the <code>export bar=...</code> command is not showing up, because of the prefix! Let's now fix it to simply understand the priority.</p> <p>Let's rerun the export command and update the env file, adding this time the prefix example_\":</p> <pre><code>export example_bar=\"I'm an env variable!\"\n</code></pre> .env<pre><code>example_foo=42\nexample_bar=\"Will I be ignored?\"\n</code></pre> <p>The output is <code>Settings(foo=42 bar=\"I'm an env variable!\")</code>!!</p> <p>The bar variable from the .env file has been totally overridden!</p>","tags":["pydantic","validation","env"]},{"location":"2024/10/18/manage-settings-with-pydantic/#evaluation-order","title":"Evaluation order","text":"<p>To sum up, the priority order for which value will be taken is:</p> <ol> <li>Values passed as input arguments</li> <li>Values loaded from the environment variables</li> <li>Values loaded from the <code>.env</code> file</li> <li>Field default values</li> </ol>","tags":["pydantic","validation","env"]},{"location":"2024/10/18/manage-settings-with-pydantic/#more-validations","title":"More validations","text":"<p>As we have seen, the type hinting lets Pydantic to validate the values based on the provided type. Pydantic has great variety of built in types, like <code>PositiveInt</code>, <code>PositiveFloat</code>, <code>FilePath</code> and also types to define sensitive data that should be kept secret (just classess that override the <code>__repr__</code> and <code>__str__</code> methods), like the <code>SecretStr</code> or the <code>PaymentCardNumber</code>.</p> <p>Let's doing an example using some of them and a custom type:</p> <pre><code>from pydantic.types import SecretStr, PositiveInt\nfrom enum import StrEnum\n\nclass Role(StrEnum):\n    READER = \"reader\"\n    MODERATOR = \"moderator\"\n    ADMIN = \"admin\"\n\nclass Settings(BaseSettings):\n    username: str\n    password: SecretStr\n    age: PositiveInt\n    role: Role = Role.READER\n</code></pre> <p>Let's create a new Setting object:</p> <p>Warning</p> <p>Never hardcode your passwords!</p> <p><pre><code>Settings(\n    username=\"Deg\", \n    password=\"not_supposed_to_be_hardcoded_here\", \n    age=29, \n    role=\"moderator\"\n  )\n</code></pre> results in <pre><code>Settings(username='Deg' password=SecretStr('**********') age=29 role=&lt;Role.MODERATOR: 'moderator'&gt;)\n</code></pre></p> <p>Changing the role to <code>\"story-teller\"</code> results in a <code>ValidationError</code>:</p> <p>1 validation error for Settings role   Input should be 'reader', 'moderator' or 'admin' [type=enum, input_value='story_teller', input_type=str]</p>","tags":["pydantic","validation","env"]},{"location":"2024/10/18/manage-settings-with-pydantic/#custom-validation","title":"Custom validation","text":"<p>It is also possible to define custom validators to be performed before or after the Field validations seen before.</p>","tags":["pydantic","validation","env"]},{"location":"2024/10/18/manage-settings-with-pydantic/#field-validators","title":"Field validators","text":"<p>The <code>field_validator</code> decorator allows to add another validator to a field. It is used to decorate only <code>classmethods</code> and accepts as input the field name and another optional argument.</p> <p>For example, we want to validate the <code>password</code> field used before in order to accept only passwords that are at least 8 characters long. We would write something like:</p> <pre><code>from pydantic import field_validator\n\nclass Settings(BaseSettings):\n    ...\n\n  @field_validator(\"password\")\n  @classmethod\n  def validate_field_length(cls, v: str):\n      if len(v) &lt; 8:\n          raise ValueError(\"The field 'password' must be at least of 8 characters long\")\n      return v\n</code></pre> <p>It is also possible to use the same validator for more than one field, listing all the fields. In this case, the message shown in the exception raised wouldn't be correct! Fortunately, a third argument gives us a hand:</p> <pre><code>from pydantic import ValidationInfo\n\n@field_validator(\"password\",\"username\")\n@classmethod\ndef validate_field_length(cls, v: str, info: ValidationInfo):\n    if len(v) &lt; 8:\n        raise ValueError(f\"The field {info.field_name} must have a length at least of 8 characters\")\n    return v\n</code></pre>","tags":["pydantic","validation","env"]},{"location":"2024/10/18/manage-settings-with-pydantic/#before-and-after-validators","title":"Before and After validators","text":"<p>Sometimes would be useful to apply some logic right before the pydantic internal validation on the types. We can do this using the <code>mode</code> attribute of the <code>field_validator</code> decorator.</p> <p>For instance, we would like to strip the input username before the type validator does its job:</p> <pre><code>class Settings(BaseSettings):\n    ...\n\n    @field_validator(\"username\", mode=\"before\")\n    @classmethod\n    def strip_raw(cls, v: Any, info: ValidationInfo):\n        if isinstance(v,str):\n            print(\"Yes, it's a string!\")\n            v = v.strip()\n        else:\n            print(\"Nope, it's a {}!\".format(type(v)))\n        return v\n</code></pre> <pre><code>Settings(username=\"Deg     \", password=\"test\", age=29, role=\"reader\")\n</code></pre> <p>Yes, it's a string!</p> <p>Settings(username='Deg' password=...)</p> <p>As you can see the, the white space has been removed and then the type validation has been performed. To better notice this, let's try passing an <code>int</code> rather than a <code>str</code>:</p> <pre><code>Settings(username=42, password=\"test\", age=29, role=\"reader\")\n</code></pre> <p>Nope, it's a &lt;class 'int'&gt;! </p> <pre><code>1 validation error for Settings\nusername\n  Input should be a valid string [type=string_type, input_value=4, input_type=int]\n</code></pre> <p>Other than running validators before, it is also possible to run them after. Sometimes could be actually useful to apply some logic to a freshly casted input data (remember that after the type validation, each input is casted from string to the correct requested type field!). The syntax is basically the same as the one seen before:</p> <pre><code>@field_validator(&lt;field_name&gt;, mode=\"after\")\n</code></pre>","tags":["pydantic","validation","env"]},{"location":"2024/10/18/manage-settings-with-pydantic/#annotated-types","title":"Annotated types","text":"<p>Instead of defining field validators, it is possible to bind a validator to a specific type. In that case would be sufficient the use of the <code>Annotated</code>, extending the type with a pydantic validator made for this purpose, like <code>BeforeValidator</code> and <code>AfterValidator</code>.</p> <p>Let's take again the strip example seen before:</p> <pre><code>from typing_extensions import Annotated\nfrom pydantic import BeforeValidator\nfrom typing import Any\n\ndef strip_raw(v: Any):\n    if isinstance(v, str):\n        print(\"Yes, it's a string!\")\n        v = v.strip()\n    else:\n        print(\"Nope, it's a {}!\".format(type(v)))\n    return v\n\nstrippedString = Annotated[str, BeforeValidator(strip_raw)]\n\n\nclass Settings(BaseSettings):\n    username: strippedString\n    password: SecretStr\n    age: PositiveInt\n    role: Role = Role.READER\n</code></pre> <p>In this way the validator is bind to the type str rather than to one or more fields.</p> <p>For more on the validators, take a look at the validators documentation.</p>","tags":["pydantic","validation","env"]},{"location":"2024/10/18/manage-settings-with-pydantic/#conclusion","title":"Conclusion","text":"<p>In this guide we have seen how to define a Settings class whose values can be changed by setting environment variables or simply loading a <code>.env</code> file. We have seen how Pydantic validates each value according to the provided field type, how to define more complex custom types and extend the validation with other functions that can be executed in a given order.</p> <p>Leveraging the power of the <code>.env</code> files and of the fields' default values we can be sure that all the instance of the class (created without any input arguments, take a look at the evaluation order) will have always the same settings. What we could do to stress this point (and avoid the tedious creation of Settings instances in all the modules in which we need to access them) is to create in our <code>settings.py</code> module an instance of the class. Given how pydantic works, it will be a naive singleton.</p> <p>To sum up</p> settings.py<pre><code>from enum import StrEnum\nfrom pydantic.types import SecretStr, PositiveInt\nfrom pydantic import BeforeValidator, field_validator, ValidationInfo\nfrom pydantic_settings import BaseSettings\nfrom typing import Any\nfrom typing_extensions import Annotated\n\nclass Role(StrEnum):\n    READER = \"reader\"\n    MODERATOR = \"moderator\"\n    ADMIN = \"admin\"\n\ndef strip_raw(v: Any):\n    if isinstance(v,str):\n        print(\"Yes, it's a string!\")\n        v = v.strip()\n    else:\n        print(\"Nope, it's a {}!\".format(type(v)))\n    return v\n\nstrippedString = Annotated[str, BeforeValidator(strip_raw)]\n\nclass Settings(BaseSettings):\n    username: strippedString\n    password: SecretStr\n    age: PositiveInt\n    role: Role = Role.READER\n\n    @field_validator(\"password\",\"username\", mode=\"after\")\n    @classmethod\n    def validate_field_length(cls, v: str, info: ValidationInfo):\n        if len(v) &lt; 8:\n            raise ValueError(f\"The field {info.field_name} must have a length at least of 8 characters\")\n        return v\n\nS = Settings()  # &lt;- import this in the other modules\n</code></pre>","tags":["pydantic","validation","env"]},{"location":"2024/10/18/manage-settings-with-pydantic/#sources","title":"Sources","text":"<ul> <li>https://docs.pydantic.dev/latest/</li> <li>https://docs.pydantic.dev/latest/concepts/pydantic_settings/#settings-management</li> <li>https://docs.pydantic.dev/latest/concepts/validators/</li> </ul>","tags":["pydantic","validation","env"]},{"location":"archive/2024/","title":"2024","text":""},{"location":"category/validation/","title":"Validation","text":""}]}