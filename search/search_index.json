{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to my personal notes","text":"<p>Multiple times I've managed to solve a new problem using an old solution, pleased to notice how much time I saved and how the quality of the final result has increased since the first time I had struggled with the original problem.</p> <p>I know, it's simply the definition of the learning curve, but I've always been fascinated by how good the brain is in learning and storing new stuff!</p> <p>In my daily work I often tend to go back and take a look at some old code that I or my colleges have written. Unfortunately this is not always possible, especially if your code is in your company's protected repositories and you are just sitting confortably on the couch, with your personal laptop on the lap, and the work laptop is in your work bag in the other room, or (much more reasonably) if you just changed job. </p> <p>For this reason I've decide to collect here some guides, tutorials and personal notes that could be useful in the future. </p> <p>Enjoy your reading!</p>"},{"location":"about/","title":"About me","text":"<p> My name is Marcello and in the last few years I have been working as Data Engineer developing ETL pipelines and tools to simplify and standardize the whole data cleansing process. I'm a sci-fi books enthusiast, cook and language learner. I strongly believe in knowledge sharing and teaching as a tool for a better learning. </p>"},{"location":"2024/10/25/create-a-comand-line-interface-in-few-minutes/","title":"Create a Comand line interface in few minutes","text":"<p>A command line interface could seem an ancient tool to all non expert users, nowadays used to fancy click and drop user interfaces. Nothing more wrong! It is also a valid tool to enhance your libraries and projects, reusable in bash scripts and ci/cd pipelines.</p> <p>In this tutorial we will deep dive into the python click library and create a simple command line interface (CLI) to manage the settings value and interact with our project.</p> <p>Where is the code?</p> <p>You can find the working code shown in this tutorial in this folder.</p>","tags":["click","pydantic","command_line_interface","python"]},{"location":"2024/10/25/create-a-comand-line-interface-in-few-minutes/#installation","title":"Installation","text":"<p>The installation is straightforward. In a virtual environment with pip installed, simply run:</p> <pre><code>pip install click\n</code></pre>","tags":["click","pydantic","command_line_interface","python"]},{"location":"2024/10/25/create-a-comand-line-interface-in-few-minutes/#a-cli-example","title":"A CLI example","text":"<p>When thinking to a CLI we usually think to one or multiple entry points that allow to perform multiple actions. For instance, when typing <code>git</code>, a long list of possible commands are shown:</p> <pre><code>git\nusage: git [-v | --version] [-h | --help] [-C &lt;path&gt;] [-c &lt;name&gt;=&lt;value&gt;]\n           [--exec-path[=&lt;path&gt;]] [--html-path] [--man-path] [--info-path]\n           [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare]\n           [--git-dir=&lt;path&gt;] [--work-tree=&lt;path&gt;] [--namespace=&lt;name&gt;]\n           [--super-prefix=&lt;path&gt;] [--config-env=&lt;name&gt;=&lt;envvar&gt;]\n           &lt;command&gt; [&lt;args&gt;]\n\nThese are common Git commands used in various situations:\n\nstart a working area (see also: git help tutorial)\n   clone     Clone a repository into a new directory\n   init      Create an empty Git repository or reinitialize an existing one\n\nwork on the current change (see also: git help everyday)\n   add       Add file contents to the index\n   mv        Move or rename a file, a directory, or a symlink\n   restore   Restore working tree files\n   rm        Remove files from the working tree and from the index\n\n...\n</code></pre> <p>Each of these command accepts arguments and options, or could also represent a group of subcommands. Usually, each command has a <code>--help</code> options and a short help message that explains that a specific command requires and does.</p>","tags":["click","pydantic","command_line_interface","python"]},{"location":"2024/10/25/create-a-comand-line-interface-in-few-minutes/#create-a-cli-to-manage-the-settings","title":"Create a CLI to manage the settings","text":"<p>In this article we have seen how to create a Settings class to set and validate settings values. Among the possible way a value can be changed is using environment variables stored in a <code>.env</code> files. Let's create a CLI to visualize the current settings and to manage them.</p>","tags":["click","pydantic","command_line_interface","python"]},{"location":"2024/10/25/create-a-comand-line-interface-in-few-minutes/#group-of-commands","title":"Group of commands","text":"<p>As said, a CLI can be composed by a group of commands.</p> <p>Let's create a first group of commands, named cli. This will be used later as entry point. To create a group, simply import click and use it's <code>@click.group</code> decorator on a function.</p> <p><pre><code>import click\n\n@click.group()\ndef cli():\n    ...\n</code></pre> Using an ellipse (<code>...</code>) in the body function, or a <code>pass</code> is sufficient: the aim of this function is simply to group other commands. Instead of an empty body we could add an explanation on what our CLI is supposed to do. </p> <p>In this example we will manage settings, but it is quite probable that a more complex CLI would be also used to execute other tasks. Let's create a group of commands that will collect a series of subcommand for the settings management. They will be in charge of:</p> <ul> <li>visualize the current settings (show)</li> <li>set a value (set)</li> <li>unset a value (unset)</li> </ul> <p><pre><code>@click.group()\ndef cli():\n    ...\n\n@click.group()\ndef settings():\n    \"\"\"Groups of commands for settings management\"\"\"\n\n@settings.command(name=\"set\", help=\"Set a setting value\")\ndef _set():\n    ...\n\n@settings.command(help=\"Show the current values\")\ndef show():\n    ...\n\n@settings.command(help=\"Unset a setting value\")\ndef unset():\n    ...\n\ncli.add_command(settings)\n</code></pre> There are few attention points here:</p> <ul> <li>The settings group command has been linked to the cli group command using <code>cli.add_command(settings)</code>. </li> <li>To link the set, unset and show commands we have instead used the <code>@settings.command</code> decorator.</li> <li>As you can see we cannot have the <code>set</code> function, since it would overwrite the python set keyword. In this case it is sufficient to specify a name in the <code>@settings.command()</code> decorator.</li> <li>A short help has been added to all the commands</li> </ul>","tags":["click","pydantic","command_line_interface","python"]},{"location":"2024/10/25/create-a-comand-line-interface-in-few-minutes/#define-an-entry-point","title":"Define an entry point","text":"<p>Before to continue specializing our cli commands, let's connect this python script to our project.</p> <p>To do so it is mandatory that our project has a configuration file that allows our project to be packaged, installed and distributed: you can use a <code>setup.cfg</code>, a <code>setup.py</code> or a <code>pyproject.toml</code> as well.</p> <p>In our example we are going to use setup.cfg for the configuration and setup.py to allow <code>pip</code> to install our project. The configuration file will contain all the metadata, the required (and optional) dependencies and also the <code>entry_points</code>. The entry points are used to link functions, modules and other element of your project to other libraries (in this way it is possible to create a plugins system, more on this extremely good article from Amir Rachum). In our case we will use the entry point to simply link the <code>cli</code> group to the project.</p> <p>From now on let's give a proper direction to our fake project: we will create a BlobDownloader, with a settings system and a CLI to manage the settings and download some blob objects.</p> <p>This is its <code>setup.cfg</code> file:</p> setup.cfg<pre><code>[metadata]\nname = blob_downloader\nversion = 0.1.0\nauthor = Marcello De Giorgi\nauthor_email = degiorgimarcello@gmail.com\ndescription = A simple blob downloader\nlong_description = file: README.md\nlong_description_content_type = text/markdown\n\n[options]\npackages = find:\npython_requires = &gt;=3.6\n\ninstall_requires =\n    azure-storage-blob==12.22.*\n    pydantic-settings==2.1.*\n    click==8.1.*\n\n[options.entry_points]\nconsole_scripts =\n    blobdow = blob_downloader.cli:cli\n</code></pre> <p>Let's ignore everything and just concentrate on the last 3 rows:</p> <pre><code>[options.entry_points]\nconsole_scripts =\n    blobdow = blob_downloader.cli:cli\n</code></pre> <p>We are basically giving a name to access our cli (blob_downloader was too long!). The <code>blob_downloader.cli:cli</code> is basically the dot-notation path to our <code>cli.py</code> file, in the <code>blob_downloader</code> package (it is a package because it has a <code>__init__.py</code> file). In particular, we are retrieving the <code>cli</code> function (the main command group!).</p> <p>Once the entry point has been added to the <code>setup.cfg</code>, we can proceed installing (better if in editable mode) the BlobDownloader.</p> <p><code>pip install -e .</code></p> <p>If everything has been installed correctly, typing <code>blobdow</code>in the terminal will pop up this: <pre><code>&gt; blobdow\nUsage: blobdow [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  settings  Groups of commands for settings management\n</code></pre></p> <p>and <code>blobdow settings</code> this:</p> <pre><code>&gt; blobdow settings\nUsage: blobdow settings [OPTIONS] COMMAND [ARGS]...\n\n  Groups of commands for settings management\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  set    Set a setting value\n  show   Show the current values\n  unset  Unset a setting value\n</code></pre>","tags":["click","pydantic","command_line_interface","python"]},{"location":"2024/10/25/create-a-comand-line-interface-in-few-minutes/#add-arguments-and-options-to-commands","title":"Add arguments and options to commands","text":"<p>Let's now start to define our commands. First of all, let's add a <code>--version</code> command. This value can be automatically inferred by click passing the name of the package from which the installed version will be taken. </p> <p>This is added directly to the <code>cli</code> group command. The <code>message</code> argument is completely optional but it always funny to give to our CLI a personalized flavour. </p> <pre><code>@click.version_option(package_name=\"blob_downloader\", message=logo)\n@click.group()\ndef cli(): ...\n</code></pre> <p>Typing <code>blobdow --version</code> results in:</p> <pre><code>&gt; blobdow --version\n\n  ____  _       _       _____                      _                 _\n |  _ \\| |     | |     |  __ \\                    | |               | |\n | |_) | | ___ | |__   | |  | | _____      ___ __ | | ___   __ _  __| | ___ _ __\n |  _ &lt;| |/ _ \\| '_ \\  | |  | |/ _ \\ \\ /\\ / / '_ \\| |/ _ \\ / _` |/ _` |/ _ \\ '__|\n | |_) | | (_) | |_) | | |__| | (_) \\ V  V /| | | | | (_) | (_| | (_| |  __/ |\n |____/|_|\\___/|_.__/  |_____/ \\___/ \\_/\\_/ |_| |_|_|\\___/ \\__,_|\\__,_|\\___|_|\n\n                                                                        v0.1.0\n</code></pre>","tags":["click","pydantic","command_line_interface","python"]},{"location":"2024/10/25/create-a-comand-line-interface-in-few-minutes/#settings-set","title":"Settings set","text":"<p>As we have seen in this article, the settings can be set via environment variables. Any changes that we will do to our settings must last also when the cli command ends its execution. Therefore, we must store any settings change in the <code>.env</code> file. </p> <pre><code>@settings.command(name=\"set\", help=\"Set a setting value\")\n@click.argument(\"name\", type=str)\n@click.argument(\"value\")\ndef _set(name, value):\n    if name in S.model_fields:\n        try:\n            S.model_validate({name: value})\n        except Exception as e:\n            click.secho(e, fg=\"red\")\n            click.get_current_context().exit(2)\n        else:\n            update_settings_file(name, value)\n            click.secho(f\"Setting '{name}' successfully updated!\", fg=\"green\")\n    else:\n        click.secho(f\"Setting '{name}' is not listed among the available settings.\", fg=\"red\")\n        click.get_current_context().exit(2)\n</code></pre> <p>Let's go over line by line:</p> <ul> <li> <p>Two <code>@click.commands</code> have been added. The first one is the name and must be of type <code>str</code> (this is not the best example on where to use the <code>type</code> option, since all the input parameters will be always string. Different would have been if the type would have been <code>int</code>, since a cast would have been then executed for validation purposes.) The second one is the value to be set. </p> <p>click will now suggest a new usage: </p> <p><code>Usage: blobdow settings set [OPTIONS] NAME VALUE</code></p> </li> <li> <p>The commands need to be also in the function argument.</p> </li> <li> <p>We first check that the <code>name</code> is listed among the settings. If this is not the case, a <code>click.secho</code> message in red will be printed.</p> <p></p> </li> <li> <p>If the name is listed in the settings, we use pydantic to validate it. </p> </li> <li> <p>If the validation is ok, we update the <code>.env</code> file     </p> </li> <li> <p>otherwise an exception is raised and printed in red.</p> <p></p> </li> </ul>","tags":["click","pydantic","command_line_interface","python"]},{"location":"2024/10/25/create-a-comand-line-interface-in-few-minutes/#settings-unset","title":"Settings unset","text":"<p>The unset is quite similar to the set. </p> <pre><code>@settings.command(help=\"Unset a setting value\")\n@click.argument(\"name\", type=str)\ndef unset(name):\n    env_path = S.model_config.get(\"env_file\")\n    if name in S.model_fields:\n        if name in dotenv_values(env_path):\n            unset_key(env_path, name)\n        click.secho(f\"Setting '{name}' unset successfully.\", fg=\"green\")\n    else:\n        click.secho(f\"Setting '{name}' does not exists.\", fg=\"red\")\n</code></pre> <p>Let's now add the option <code>--all</code> to restore to the default value all the settings all at once. To do so, we just need to remove the <code>.env</code> file. This can be done in different ways: let's use a callback. </p>","tags":["click","pydantic","command_line_interface","python"]},{"location":"2024/10/25/create-a-comand-line-interface-in-few-minutes/#options-callbacks","title":"Options' callbacks","text":"<p>Callbacks allow to alter the execution flow defined in the command body: this can be quite usefule in some cases, expecially when associated with the command <code>is_eager=True</code>, that ignore all the other options and arguments and execute the callback first!</p> <pre><code>def remove_env_file(ctx, param, value):\n    \"\"\"Remove the env file\"\"\"\n    if not value or ctx.resilient_parsing:\n        return\n    if click.confirm(\"Are you sure you want to delete the .env file?\", abort=True):\n        env_path = S.model_config.get(\"env_file\")\n        if env_path and exists(env_path):\n            remove(env_path)\n            click.secho(f\"File .env ({env_path}) removed correctly.\")\n        ctx.exit(0)\n...\n@click.option(\"-a\", \"--all\", is_flag=True, callback=remove_env_file,  help=\"Restore all the settings\")\ndef unset(name):\n    ...\n</code></pre> <p>A lot of stuff here! Let's start from the end. The option decorator accepts as input a short and a long name (you are not force to define them all). The <code>is_flag</code> specifies that the option does not require any value after and that it's own presence is equals to the value <code>True</code>. The <code>callback</code> argument is the function defined above.</p> <p>The Callback signature requires the current context <code>ctx</code>, the command <code>params</code> and the <code>value</code> of the option. The following block is a common pattern in the click callbacks:</p> <p><pre><code>if not value or ctx.resilient_parsing:\n    return\n</code></pre> It is used to prevent the callback execution in those cases in which click parses the command (resilient parsing): if you try to remove it, you will notice that the callback will be executed even if the <code>--all</code> option is not passed.</p> <p>The <code>click.confirm</code> function returns a prompt (y/n) to the user, quite useful in a lot of situations.</p>","tags":["click","pydantic","command_line_interface","python"]},{"location":"2024/10/25/create-a-comand-line-interface-in-few-minutes/#a-simpler-solution","title":"A simpler solution","text":"<p>Use a callback for our purpose has been like shooting a mosquito with a bazooka. Callbacks are usually used for validating or transforming the input parameters before to continue with the command body. We could have achieved the same purpose using an <code>if/else</code> statement.</p> <pre><code>@settings.command(help=\"Unset a setting value\")\n@click.argument(\"name\", type=str)\n@click.option(\"-a\", \"--all\", is_flag=True, help=\"Restore all the settings\")\ndef unset(name, all):\n    if all:\n        # remove the .env file and quit\n        ...\n    env_path = S.model_config.get(\"env_file\")\n    if name in S.model_fields:\n        if name in dotenv_values(env_path):\n            unset_key(env_path, name)\n        click.secho(f\"Setting '{name}' unset successfully.\", fg=\"green\")\n    else:\n        click.secho(f\"Setting '{name}' does not exists.\", fg=\"red\")\n</code></pre>","tags":["click","pydantic","command_line_interface","python"]},{"location":"2024/10/25/create-a-comand-line-interface-in-few-minutes/#settings-show","title":"Settings show","text":"<p>The <code>settings</code> command does not requires special arguments or options. We just need to print the settings names, the values and (optionally) the default ones.</p> <pre><code>@settings.command(help=\"Show the current values\")\ndef show():\n    click.echo(\"\\n\")\n    for name, values in S.model_fields.items():\n        default = values.default\n        click.echo(f\"{name}: \", nl=False)\n        click.secho(getattr(S,name),fg=\"green\", nl=False)\n        click.echo(\" (\", nl=False)\n        click.secho(f\"{default}\", fg=\"red\", nl=False)\n        click.echo(\")\")\n\n    click.echo(\"\\n\")\n</code></pre> <p><code>blobdow settings show</code> results in:</p> <p></p>","tags":["click","pydantic","command_line_interface","python"]},{"location":"2024/10/25/create-a-comand-line-interface-in-few-minutes/#conclusion","title":"Conclusion","text":"<p>In this article we have seen only the peak of the iceberg of this wonderful library. In few lines of code we have been able to create a simple but effective and quite useful command line interface to manage the settings of our project. We still need to test that everything works properly, but that will be a subject for another article!</p>","tags":["click","pydantic","command_line_interface","python"]},{"location":"2024/10/25/create-a-comand-line-interface-in-few-minutes/#sources","title":"Sources","text":"<ul> <li>https://click.palletsprojects.com/en/8.1.x/</li> <li>https://amir.rachum.com/python-entry-points/</li> <li>https://click.palletsprojects.com/en/stable/arguments/</li> <li>https://click.palletsprojects.com/en/stable/options/</li> </ul>","tags":["click","pydantic","command_line_interface","python"]},{"location":"2024/10/18/manage-settings-with-pydantic/","title":"Manage settings with Pydantic","text":"<p> Pydantic is a wonderful library that allows to easily validate your data, simply defining a schema. It is highly customizable and can be used, for instance, to validate data coming from a POST request. </p> <p>In this tutorial we will use it to create a <code>Settings</code> class whose fields can be changed in different ways, triggering any time the validation.</p>","tags":["pydantic","validation","env"]},{"location":"2024/10/18/manage-settings-with-pydantic/#installation","title":"Installation","text":"<p>From v2, pydantic has been split in <code>pydantic</code>, <code>pydantic-core</code> and <code>pydnatic-settings</code>. Let's install the latter one simply with:</p> <p><code>pip install pydantic-settings</code>.</p>","tags":["pydantic","validation","env"]},{"location":"2024/10/18/manage-settings-with-pydantic/#class-definition-and-usage","title":"Class definition and usage","text":"<p>Let's start defining our class. It must extend the pydantic <code>BaseSettings</code> class. No <code>__init__</code> is here needed.</p> <pre><code>from pydantic_settings import BaseSettings\n\nclass Settings(BaseSettings):\n    foo: int = 1\n    bar: str = \"eeee\"\n</code></pre> <p>Extending the class and defining some fields with type hinting is sufficient to let pydantic trigger the validation anytime this values are changed.</p> <p>We can change the values simply defining a new <code>Settings</code> object and passing some values for the fields. This is not so useful for our purpose but can help us to understand how the validation works.</p> <pre><code>Settings(foo=5)\n&gt; Settings(foo=5, bar='eeee')\n</code></pre> <p>but </p> <p><pre><code>Settings(foo=\"five\")\n</code></pre> raise the following exception:</p> <p>ValidationError: 1 validation error for Settings foo   Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='five', input_type=str]</p>","tags":["pydantic","validation","env"]},{"location":"2024/10/18/manage-settings-with-pydantic/#environment-variables","title":"Environment variables","text":"<p>For sure it is more useful to set the settings values directly changing the environment variables. This can be done using the <code>export</code> command on Linux or the <code>set</code> one on Windows. Let's try what happens changing the value of the bar field and to instance a <code>Setting</code> object without any input argument.</p> <p><pre><code>export bar=\"I'm an env variable!\"\n</code></pre> <pre><code>Settings()\n&gt; Settings(foo=1, bar=\"I'm an env variable!\")\n</code></pre></p> <p>If we then pass an input argument it will have the precedence! <pre><code>Settings(bar=\"?\")\n&gt; Settings(foo=1, bar='?')\n</code></pre></p>","tags":["pydantic","validation","env"]},{"location":"2024/10/18/manage-settings-with-pydantic/#using-a-env-file","title":"Using a .env file","text":"<p>Sometimes could be useful to collect more environment variables in a <code>.env</code> file. There is no need to load this file at the beginning of the module, pydantic will do this for us. To do so, the path to the file must be specified. For this and other configuration, our <code>Settings</code> class must be a little bit changed, including the <code>SettingsConfigDict</code>:</p> <pre><code>from pydantic_settings import BaseSettings, SettingsConfigDict\nfrom os.path import expanduser\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(\n        env_file=expanduser(\"~/.env\"), \n        env_file_encoding=\"utf-8\",\n        env_prefix=\"example_\"\n      )\n\n    foo: int = 1\n    bar: str = \"eeee\"\n</code></pre> <p>Let's take a look at the new addings:</p> <ul> <li><code>env_file</code>: the path to the <code>.env</code> file</li> <li><code>env_file_econding</code>: for specifying an encoding different from the one used by your OS</li> <li><code>env_prefix</code>: to specify a prefix that ALL the variables must have to be considered field of the <code>Settings</code> class.</li> </ul> <p>Let's fill our file with the variables:</p> .env<pre><code>example_foo=42\nbar=\"Will I be ignored?\"\n</code></pre> <p>Let's now create another Settings object:</p> <p><pre><code>Settings()\n&gt; Settings(foo=42 bar='eeee')\n</code></pre> As you can see, the <code>bar</code> variable has not been taken, since no <code>env_prefix</code> has been used. Furthermore, the previous values set using the <code>export bar=...</code> command is not showing up, because of the prefix! Let's now fix it to simply understand the priority.</p> <p>Let's rerun the export command and update the env file, adding this time the prefix example_\":</p> <pre><code>export example_bar=\"I'm an env variable!\"\n</code></pre> .env<pre><code>example_foo=42\nexample_bar=\"Will I be ignored?\"\n</code></pre> <p>The output is <code>Settings(foo=42 bar=\"I'm an env variable!\")</code>!!</p> <p>The bar variable from the .env file has been totally overridden!</p>","tags":["pydantic","validation","env"]},{"location":"2024/10/18/manage-settings-with-pydantic/#evaluation-order","title":"Evaluation order","text":"<p>To sum up, the priority order for which value will be taken is:</p> <ol> <li>Values passed as input arguments</li> <li>Values loaded from the environment variables</li> <li>Values loaded from the <code>.env</code> file</li> <li>Field default values</li> </ol>","tags":["pydantic","validation","env"]},{"location":"2024/10/18/manage-settings-with-pydantic/#more-validations","title":"More validations","text":"<p>As we have seen, the type hinting lets Pydantic to validate the values based on the provided type. Pydantic has great variety of built in types, like <code>PositiveInt</code>, <code>PositiveFloat</code>, <code>FilePath</code> and also types to define sensitive data that should be kept secret (just classess that override the <code>__repr__</code> and <code>__str__</code> methods), like the <code>SecretStr</code> or the <code>PaymentCardNumber</code>.</p> <p>Let's doing an example using some of them and a custom type:</p> <pre><code>from pydantic.types import SecretStr, PositiveInt\nfrom enum import StrEnum\n\nclass Role(StrEnum):\n    READER = \"reader\"\n    MODERATOR = \"moderator\"\n    ADMIN = \"admin\"\n\nclass Settings(BaseSettings):\n    username: str\n    password: SecretStr\n    age: PositiveInt\n    role: Role = Role.READER\n</code></pre> <p>Let's create a new Setting object:</p> <p>Warning</p> <p>Never hardcode your passwords!</p> <p><pre><code>Settings(\n    username=\"Deg\", \n    password=\"not_supposed_to_be_hardcoded_here\", \n    age=29, \n    role=\"moderator\"\n  )\n</code></pre> results in <pre><code>Settings(username='Deg' password=SecretStr('**********') age=29 role=&lt;Role.MODERATOR: 'moderator'&gt;)\n</code></pre></p> <p>Changing the role to <code>\"story-teller\"</code> results in a <code>ValidationError</code>:</p> <p>1 validation error for Settings role   Input should be 'reader', 'moderator' or 'admin' [type=enum, input_value='story_teller', input_type=str]</p>","tags":["pydantic","validation","env"]},{"location":"2024/10/18/manage-settings-with-pydantic/#custom-validation","title":"Custom validation","text":"<p>It is also possible to define custom validators to be performed before or after the Field validations seen before.</p>","tags":["pydantic","validation","env"]},{"location":"2024/10/18/manage-settings-with-pydantic/#field-validators","title":"Field validators","text":"<p>The <code>field_validator</code> decorator allows to add another validator to a field. It is used to decorate only <code>classmethods</code> and accepts as input the field name and another optional argument.</p> <p>For example, we want to validate the <code>password</code> field used before in order to accept only passwords that are at least 8 characters long. We would write something like:</p> <pre><code>from pydantic import field_validator\n\nclass Settings(BaseSettings):\n    ...\n\n  @field_validator(\"password\")\n  @classmethod\n  def validate_field_length(cls, v: str):\n      if len(v) &lt; 8:\n          raise ValueError(\"The field 'password' must be at least of 8 characters long\")\n      return v\n</code></pre> <p>It is also possible to use the same validator for more than one field, listing all the fields. In this case, the message shown in the exception raised wouldn't be correct! Fortunately, a third argument gives us a hand:</p> <pre><code>from pydantic import ValidationInfo\n\n@field_validator(\"password\",\"username\")\n@classmethod\ndef validate_field_length(cls, v: str, info: ValidationInfo):\n    if len(v) &lt; 8:\n        raise ValueError(f\"The field {info.field_name} must have a length at least of 8 characters\")\n    return v\n</code></pre>","tags":["pydantic","validation","env"]},{"location":"2024/10/18/manage-settings-with-pydantic/#before-and-after-validators","title":"Before and After validators","text":"<p>Sometimes would be useful to apply some logic right before the pydantic internal validation on the types. We can do this using the <code>mode</code> attribute of the <code>field_validator</code> decorator.</p> <p>For instance, we would like to strip the input username before the type validator does its job:</p> <pre><code>class Settings(BaseSettings):\n    ...\n\n    @field_validator(\"username\", mode=\"before\")\n    @classmethod\n    def strip_raw(cls, v: Any, info: ValidationInfo):\n        if isinstance(v,str):\n            print(\"Yes, it's a string!\")\n            v = v.strip()\n        else:\n            print(\"Nope, it's a {}!\".format(type(v)))\n        return v\n</code></pre> <pre><code>Settings(username=\"Deg     \", password=\"test\", age=29, role=\"reader\")\n</code></pre> <p>Yes, it's a string!</p> <p>Settings(username='Deg' password=...)</p> <p>As you can see the, the white space has been removed and then the type validation has been performed. To better notice this, let's try passing an <code>int</code> rather than a <code>str</code>:</p> <pre><code>Settings(username=42, password=\"test\", age=29, role=\"reader\")\n</code></pre> <p>Nope, it's a &lt;class 'int'&gt;! </p> <pre><code>1 validation error for Settings\nusername\n  Input should be a valid string [type=string_type, input_value=4, input_type=int]\n</code></pre> <p>Other than running validators before, it is also possible to run them after. Sometimes could be actually useful to apply some logic to a freshly casted input data (remember that after the type validation, each input is casted from string to the correct requested type field!). The syntax is basically the same as the one seen before:</p> <pre><code>@field_validator(&lt;field_name&gt;, mode=\"after\")\n</code></pre>","tags":["pydantic","validation","env"]},{"location":"2024/10/18/manage-settings-with-pydantic/#annotated-types","title":"Annotated types","text":"<p>Instead of defining field validators, it is possible to bind a validator to a specific type. In that case would be sufficient the use of the <code>Annotated</code>, extending the type with a pydantic validator made for this purpose, like <code>BeforeValidator</code> and <code>AfterValidator</code>.</p> <p>Let's take again the strip example seen before:</p> <pre><code>from typing_extensions import Annotated\nfrom pydantic import BeforeValidator\nfrom typing import Any\n\ndef strip_raw(v: Any):\n    if isinstance(v, str):\n        print(\"Yes, it's a string!\")\n        v = v.strip()\n    else:\n        print(\"Nope, it's a {}!\".format(type(v)))\n    return v\n\nstrippedString = Annotated[str, BeforeValidator(strip_raw)]\n\n\nclass Settings(BaseSettings):\n    username: strippedString\n    password: SecretStr\n    age: PositiveInt\n    role: Role = Role.READER\n</code></pre> <p>In this way the validator is bind to the type str rather than to one or more fields.</p> <p>For more on the validators, take a look at the validators documentation.</p>","tags":["pydantic","validation","env"]},{"location":"2024/10/18/manage-settings-with-pydantic/#conclusion","title":"Conclusion","text":"<p>In this guide we have seen how to define a Settings class whose values can be changed by setting environment variables or simply loading a <code>.env</code> file. We have seen how Pydantic validates each value according to the provided field type, how to define more complex custom types and extend the validation with other functions that can be executed in a given order.</p> <p>Leveraging the power of the <code>.env</code> files and of the fields' default values we can be sure that all the instance of the class (created without any input arguments, take a look at the evaluation order) will have always the same settings. What we could do to stress this point (and avoid the tedious creation of Settings instances in all the modules in which we need to access them) is to create in our <code>settings.py</code> module an instance of the class. Given how pydantic works, it will be a naive singleton.</p> <p>To sum up</p> settings.py<pre><code>from enum import StrEnum\nfrom pydantic.types import SecretStr, PositiveInt\nfrom pydantic import BeforeValidator, field_validator, ValidationInfo\nfrom pydantic_settings import BaseSettings\nfrom typing import Any\nfrom typing_extensions import Annotated\n\nclass Role(StrEnum):\n    READER = \"reader\"\n    MODERATOR = \"moderator\"\n    ADMIN = \"admin\"\n\ndef strip_raw(v: Any):\n    if isinstance(v,str):\n        print(\"Yes, it's a string!\")\n        v = v.strip()\n    else:\n        print(\"Nope, it's a {}!\".format(type(v)))\n    return v\n\nstrippedString = Annotated[str, BeforeValidator(strip_raw)]\n\nclass Settings(BaseSettings):\n    username: strippedString\n    password: SecretStr\n    age: PositiveInt\n    role: Role = Role.READER\n\n    @field_validator(\"password\",\"username\", mode=\"after\")\n    @classmethod\n    def validate_field_length(cls, v: str, info: ValidationInfo):\n        if len(v) &lt; 8:\n            raise ValueError(f\"The field {info.field_name} must have a length at least of 8 characters\")\n        return v\n\nS = Settings()  # &lt;- import this in the other modules\n</code></pre>","tags":["pydantic","validation","env"]},{"location":"2024/10/18/manage-settings-with-pydantic/#sources","title":"Sources","text":"<ul> <li>https://docs.pydantic.dev/latest/</li> <li>https://docs.pydantic.dev/latest/concepts/pydantic_settings/#settings-management</li> <li>https://docs.pydantic.dev/latest/concepts/validators/</li> </ul>","tags":["pydantic","validation","env"]},{"location":"archive/2024/","title":"2024","text":""},{"location":"category/python/","title":"Python","text":""},{"location":"category/validation/","title":"Validation","text":""}]}